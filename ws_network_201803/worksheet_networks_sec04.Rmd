---
title: "Dublin Data Science Workshop on the Statistical Analysis of Networks"
subtitle: "Section 4"
author: "Mick Cooney <mickcooney@gmail.com>"
date: "Monday, March 26 2018"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    theme: cerulean
    toc: yes
  word_document:
    toc: yes
  pdf_document: default
---

```{r knit_opts, include = FALSE}
knitr::opts_chunk$set(tidy  = FALSE
                     ,cache = FALSE
                     ,message = FALSE
                     ,warning = FALSE
                     ,fig.height =  8
                     ,fig.width  = 11)

library(tidyverse)
library(scales)
library(cowplot)

library(ggnetwork)
library(igraph)
library(igraphdata)
library(sand)
library(intergraph)
library(ergm)


options(width = 80L
       ,warn  = 1
        )

set.seed(42)


source('data_setup.R')

source('custom_functions.R')
```


# Exponential Random Graph Models

The previous models we have used served a purpose, but are limited - these
approaches are analogous to building models by fitting distributions.

We now move on to more sophisticated statistical models - Exponential Random
Graph Models (ERGMs) in particular. Other approaches exist, such as stochastic
block models and latent network models, but we will not have much time to
discuss these.

Suppose we have a graph $G = (V, E)$ - let $Y$ be the adjacency matrix for this
graph and $y$ is a particular realisation of this graph.

$$
P(Y = y) = \frac{1}{\kappa} \, \exp \left( \sum_H \theta_H g_H(y) \right)
$$

where

  * $H$ is a network configuration
  * $g_H(y)$ is an indicator function for $y$ matching the configuration $H$ 
  * $\theta_H$ being non-zero means that $Y_{ij}$ are dependent
  * $\kappa$ is the normalisation constant

In simpler terms, we fit the network based on counts of characteristics of the
graph such as edges, triangles, stars and anything else we can think of.


## Network Characteristics

We build our first model from edges - we assume only the presence of edges
between nodes is relevant for the creation of the graph.

The function `summary.statistics` counts the various configurations in the
network.

```{r ergm_lazega_edge_counts, echo=TRUE}
summary.statistics(lazega_network ~ edges)
```

We now extend this model to see other configuration types including k-stars
and so on.

```{r ergm_lazega_config_counts, echo=TRUE}
summary.statistics(lazega_network ~ edges + kstar(2) + kstar(3) + triangle)
```

In practice, adding $k$-stars directly as characteristics of networks results
in poor fits so we instead have an alternative formulation that allows us to
fit for all orders of star effects simultaneously. The ones we discuss are all
parameterised allowing control over how the characteristics affect the value.

### Alternating k-Star Statistic `altkstar`

$$
\text{AKS}_{\lambda}(y) = \sum_{k=2}^{N_v-1} (-1)^k \frac{S_k(y)}{\lambda^{k-2}}
$$
where $S_k(y)$ is the number of $k$-stars in the graph.


### Geometrically-Weighted Degree Count `gwdegree`

$$
\text{GWD}_{\gamma}(y) = \sum_{d=0}^{N_v-1} e^{-\gamma d} \, N_d(y)
$$

where $N_d(y)$ is the number of vertices of degree $d$.

### Alternating k-Triangles `gwesp`

$$
\text{AKT}_{\lambda}(y) = 3T_1 + \sum_{k=2}^{N_v-2} (-1)^{k+1} \frac{T_k(y)}{\lambda^{k-1}}
$$

where $T_k$ is the number of $k$-triangles, the set of $k$ individual triangles
sharing a common base.


In our models we use the AKT quantity to match the textbook, but any can be
used.



```{r ergm_lazega_alt, echo=TRUE}
summary.statistics(lazega_network ~ edges + gwesp(1, fixed = TRUE))

summary.statistics(lazega_network ~ edges + triangles + gwdegree(1, fixed = TRUE))
```


## Attribute Characteristics

So far we have kept our focus on purely topographic properties of the networks,
ignoring the attributes of the edges or vertices.

It is natural to expect that the existence or not of an edge between two
vertices to also depend on the attributes of those vertices. We can incorporate
them into our ERGMs as additional terms.

Vertex attributes can influence a graph in two ways: a value on a vertex may
influence the probability of an edge being connected (analogous to a 'main'
effect in standard modelling), and the values on both vertices may influence
the probability (analogous to 'interactions' or 'second-order effects').

These predictors are added to a formula via the `nodemain` and `match` terms.

```{r ergm_lazega_vertex_formula, echo=TRUE}
summary.statistics(lazega_network ~ edges + triangles + gwdegree(1, fixed = TRUE) +
    nodemain('Practice') + match('Office'))
```


## Fitting ERGMs

To fit these models, we use an MCMC algorithm to calculate the MLE for the
model. The `ergm()` function performs this optimisation.

### Node Geometry

We start fitting the model with some simple geometries as predictors.

```{r fit_ergm_01, echo=TRUE}
lazega_01_ergm <- ergm(lazega_network ~ edges + triangles + gwesp(1)
   ,control = control.ergm(seed = 42)
)

run_ergm <- function() simulate.ergm(lazega_01_ergm) %>% intergraph::asIgraph()

lazega_01_lst <- run_network_model_assessment(lazega_igraph, run_ergm, n_iter = 1000)

plot(lazega_01_lst$assess_plot)
```

We have simulated new graphs from this model using `simulate.ergm()` so we
will produce one and then plot the two beside each other.

```{r plot_simulated_graph, echo=TRUE}
plot_1 <- ggplot(lazega_igraph, aes(x = x, y = y, xend = xend, yend = yend)) +
    geom_edges() +
    geom_label(aes(label = vertex.names), size = 5) +
    theme_blank()

plot_2 <- ggplot(simulate.ergm(lazega_01_ergm), aes(x = x, y = y, xend = xend, yend = yend)) +
    geom_edges() +
    geom_label(aes(label = vertex.names), size = 5) +
    theme_blank()


plot_grid(plot_1, plot_2, ncol = 2)
```

We will have a look at the degree distribution of the original network and the
simulated ERGM from it.

```{r plot_degree_dist_simulated_graph_01, echo=TRUE}
lazega_degdist <- lazega_igraph %>%
    igraph::degree()

lazega_01_degdist <- simulate.ergm(lazega_01_ergm) %>%
    intergraph::asIgraph() %>%
    igraph::degree()

plot_1 <- ggplot() +
    geom_histogram(aes(x = lazega_degdist), binwidth = 1) +
    xlab("Degree") +
    ylab("Count") +
    ggtitle("Original Network")

plot_2 <- ggplot() +
    geom_histogram(aes(x = lazega_01_degdist), binwidth = 1) +
    xlab("Degree") +
    ylab("Count") +
    ggtitle("ERGM Simulation")

plot_grid(plot_1, plot_2, ncol = 2)
```



### Vertex Attributes

We now want to see the model running with 

```{r fit_ergm_02, echo=TRUE}
lazega_02_ergm <- ergm(lazega_network ~ edges + triangles +
    gwesp(1) + nodefactor('Practice') +
    nodemain('Seniority') + nodematch('Gender') + match('Office')
   ,control = control.ergm(seed = 42)
)


run_02_ergm <- function() simulate.ergm(lazega_02_ergm) %>% intergraph::asIgraph()

lazega_02_lst <- run_network_model_assessment(lazega_igraph, run_02_ergm, n_iter = 1000)

plot(lazega_02_lst$assess_plot)
```


```{r plot_degree_dist_simulated_graph_02, echo=TRUE}
lazega_degdist <- lazega_igraph %>%
    igraph::degree()

lazega_02_degdist <- simulate.ergm(lazega_02_ergm) %>%
    intergraph::asIgraph() %>%
    igraph::degree()

plot_1 <- ggplot() +
    geom_histogram(aes(x = lazega_degdist), binwidth = 1) +
    xlab("Degree") +
    ylab("Count") +
    ggtitle("Lazega")

plot_2 <- ggplot() +
    geom_histogram(aes(x = lazega_01_degdist), binwidth = 1) +
    xlab("Degree") +
    ylab("Count") +
    ggtitle("Model 01")

plot_3 <- ggplot() +
    geom_histogram(aes(x = lazega_02_degdist), binwidth = 1) +
    xlab("Degree") +
    ylab("Count") +
    ggtitle("Model 02")

plot_grid(plot_1, plot_2, plot_3, ncol = 3)
```







