\documentclass[9pt]{beamer}

\makeatletter
\g@addto@macro\@verbatim\tiny
\makeatother

\usepackage{graphicx}
\usepackage{eurosym}
\usepackage{hyperref}



\usetheme[compress]{Berlin}


\title[From R to Julia: Converting Workshop Code]{From R to Julia: Converting Workshop Code}
\author{Mick Cooney\\ michael.cooney@applied.ai}
\date{10 March 2016}

<<setoptions, include=TRUE, echo=FALSE, cache=FALSE, results='hide'>>=
opts_knit$set(root.dir = ".")

opts_chunk$set(fig.path = './');
opts_chunk$set(fig.align = 'center');
opts_chunk$set(out.width  = '11cm');
opts_chunk$set(out.height =  '6cm');

opts_chunk$set(size = 'tiny');

set.seed(42);

@

<<init, echo=FALSE, cache=FALSE, results='hide', warning=FALSE, message=FALSE>>=
#dev_mode(TRUE)

require(ggplot2)
require(data.table)
require(gridExtra)
require(runr)

j <- proc_julia()
j$start()
knit_engines$set(julia = function(options) {
    knitr:::wrap(j$exec(options$code), options)
})

@



\begin{document}

\begin{frame}
\titlepage
\end{frame}



%%%
%%%  Section: Introduction
%%%

\section{Introduction}

%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


\end{frame}


%%%
%%%  Section: Power Control Algorithm
%%%

\section{Power Control Algorithm}

%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{Power Control Algorithm}

\begin{figure}[h]
\begin{center}
\includegraphics[height=2cm]{transmitter_receiver_gain.png}
\end{center}
\end{figure}

\begin{itemize}
    \item Network of $n$ transmitter/receiver pairs
    \item Power level: $p_i > 0$, Gain: $G_{ij} > 0$, Threshold: $\gamma$
    \item Signal power at receiver $i$: $s_i = G_{ii} p_i$.
    \item Noise plus interference: $q_i = \sigma + \sum_{j \neq i} G_{ij} p_j$
    \item SINR: $S_i = \frac{s_i}{q_i} = \alpha \gamma$, safety margin: $\alpha$
\end{itemize}

\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}

Simple power update algorithm:

\[ p_i (t+1) = p_i (t) \left( \frac{\alpha \gamma}{S_i(t)} \right) \]

Rearrange in matrix form:

\begin{equation*}
\renewcommand\arraystretch{1.5}
\begin{bmatrix}
  p_1(t+1)\\
  p_2(t+1)\\
  p_3(t+1)
\end{bmatrix}
  =
\begin{bmatrix}
0                                   & \frac{\alpha \gamma G_{12}}{G_{11}} & \frac{\alpha \gamma G_{13}}{G_{11}}\\
\frac{\alpha \gamma G_{21}}{G_{22}} & 0                                   & \frac{\alpha \gamma G_{23}}{G_{22}}\\
\frac{\alpha \gamma G_{31}}{G_{33}} & \frac{\alpha \gamma G_{32}}{G_{33}} & 0
\end{bmatrix}
\begin{bmatrix}
  p_1(t)\\
  p_2(t)\\
  p_3(t)
\end{bmatrix}
+
\begin{bmatrix}
\frac{\alpha \gamma \sigma}{G_{11}}\\
\frac{\alpha \gamma \sigma}{G_{22}}\\
\frac{\alpha \gamma \sigma}{G_{33}}
\end{bmatrix}
\end{equation*}

\begin{equation*}
  p_i(t+1) = A p(t) + b
\end{equation*}

\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}

Plot SINR and power output over time

<<prob1_data_setup1, echo=TRUE, cache=FALSE, results='true', warning=FALSE, message=FALSE, size='tiny'>>=
G <- matrix(c(1.0, 0.2, 0.2,
              0.1, 2.0, 0.4,
              0.3, 0.1, 3.0), ncol = 3, byrow = TRUE);

gamma <- 3.0;
alpha <- 1.2;
sigma <- 0.01;

N <- dim(G)[1];

mask  <- 1 - diag(N);
numer <- alpha * gamma * G;
denom <- matrix(rep(diag(G), N), ncol = N);

A <- mask * (numer / denom)

b <- alpha * gamma * sigma / diag(G)

q_mat <- mask * G;

n_iter <- 25;

pout    <- matrix(0, ncol = n_iter, nrow = N);
SINRout <- matrix(0, ncol = n_iter, nrow = N);

p0 <- rep(0.1, N);

pout[,1]    <- p0;
q           <- sigma + q_mat %*% p0;
SINRout[,1] <- (diag(G) * pout[,1]) / q;

@


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


<<prob1_data_setup2, echo=TRUE, cache=FALSE, results='true', warning=FALSE, message=FALSE>>=

for(i in 1:(n_iter-1)) {
    pout[,i+1] <- A %*% pout[,i] + b;

    q <- sigma + q_mat %*% pout[,i+1];

    SINRout[,i+1] <- (diag(G) * pout[,i+1]) / q;
}

power.plot <- qplot(Var2, value, data = melt(pout), geom = 'line', colour = as.character(Var1), size = I(0.5)) +
    xlab('Time') + ylab('Power') +
    expand_limits(y = 0) +
    theme(legend.position = 'bottom') +
    scale_colour_discrete(name = 'Transmitter');

sinr.plot <- qplot(Var2, value, data = melt(SINRout), geom = 'line', colour = as.character(Var1), size = I(0.5)) +
    xlab('Time') + ylab('SINR') +
    expand_limits(y = 0) +
    theme(legend.position = 'bottom') +
    scale_colour_discrete(name = 'Transmitter');

@


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}

<<prob1_data_setup3, echo=TRUE, cache=FALSE, results='true', warning=FALSE, message=FALSE>>=

grid.arrange(power.plot, sinr.plot, nrow = 2);

@


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{Julia Code}





\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


\end{frame}


%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{}


\end{frame}




%%%
%%%  New Frame
%%%

\begin{frame}[fragile]{Summary}

\begin{center}

\href{mailto:michael.cooney@applied.ai}{michael.cooney@applied.ai}\\

\vspace{3mm}

Slides and code available on BitBucket:\\

\footnotesize
\url{https://www.bitbucket.org/kaybenleroll/dublin_r_workshops}
\end{center}


<<close_doc, echo=FALSE, cache=FALSE, results='hide', warning=FALSE, message=FALSE>>=
j$stop()
@

\end{frame}




\end{document}
